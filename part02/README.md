# 简答题
- 一、请说出下列最终执行结果，并解释为什么 
```
var a = []
for(var i = 0; i < 10; i ++){
    a[i] = function(){
        console.log(i)
    }
}
a[6]()
```
结果：输出结果为10
解释：此处用var申明变量，var有变量提升的特点，在for里面会提升为全局变量，正常的for循环里面一边循环一边输出是没问题，但放入
function里面，后置执行时，输出的i是全局的最后一次赋值给i的值，这里在 for 循环里边赋的值，最后一次赋值是 10，所以不管调用 
a 里边第几个 function ，输出的都是 10
- 二、请说出下列最终执行结果，并解释为什么
```
var tmp = 123
if(true) {
    console.log(tmp)
    let tmp
}
```
结果：报错（无法在初始化之前访问'tmp'）
解释：在if中用es6语法let，let有3个特性：1.不存在变量提升2.暂时性死区3.不允许重复申明；这里的tmp在if中用let申明，所以在if的作用域块内部使用tmp；不受外部全局变量的影响，而let声明的变量不能在声明前被调用，所以这里会报错。
- 三、结合 ES6 新语法，用最简单的方式找出数组中的最小值
```
var arr = [12, 34, 32, 89, 4]

Math.min(...arr)
```
- 四、请详细说明 var, let, const 三种声明变量的方式之间的具体差别

   | var | let | const
-------- | ----- | ----- | ------
语法 | var a =1 | let a = 1 | const a = 1
变量提升 | 声明提升使用undefined初始化 | 仅声明提升，未初始化 | 仅声明提升，未初始化
作用域 | 全局或函数作用域 | 块级作用域 | 块级作用域
初始化 | 可以仅声明不初始化 | 可以仅声明不初始化 | 必须声明时初始化
重复定义 | 可以 | 不可以 | 不可以
多次赋值 | 可以 | 可以 | 基本数据类型不可以，引用类型仅可改变内部的值
声明前访问 | 可以 | 不可以 | 不可以
- 五、请输出下列代码最终输出结果，并解释为什么。
```
var a = 10
var obj = {
    a:20,
    fn () {
        setTimeout(() => {
            console.log(this.a)
        })
    }
}
obj.fn()
```
结果： 20
解释：先看setTimeout里面的是箭头函数，内部的this指向外部的this，而fn的函数里没有箭头函数，它的this指向调用者，即obj对象，所以这里的this指向obj本身，即this.a为20
- 六、简述 Symbol 类型的用途
1.用于创建独一无二的值，可做唯一key用于缓存等场景
2.用于创建类的私有变量,利用symbol属性不能被枚举的特性声明作为私有属性
3.用来重置对象的属性
4.可实现 Symbol.iterator迭代器， 让普通对象变为可迭代对象
5.使用Symbol.for(‘xxx’)获取全局的symbol值
- 七、说说什么是浅拷贝，什么是深拷贝
浅拷贝：也就是拷贝A对象里面的数据，但是不拷贝A对象里面的子对象
深拷贝：会克隆出一个对象，数据相同，但是引用地址不同（就是拷贝A对象里面的数据，而且拷贝它里面的子对象）
- 八、简述 TypeScript 与 JavaScript 之间的关系
Javascript是基于此标准进行实现和扩展的；TypeScript是由微软开发的自由和开源的编程语言，可以编译出纯净、 简洁的JavaScript代码，并且可以运行在任何浏览器上
TypeScript的优势：它有更多的规则和类型限制，代码具有更高的预测性、可控性，易于维护和调试
TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程，是一种给 JavaScript 添加特性的语言扩展
- 九、请谈谈你所认为的 TypeScript 优缺点
优点：
（1）增强代码的可读性和可维护性，强类型的系统相当于最好的文档，在编译时即可发现大部分的错误，增强编辑器的功能。
（2）包容性，js文件可以直接改成 ts 文件，不定义类型可自动推论类型，可以定义几乎一切类型，ts 编译报错时也可以生成 js 文件，兼容第三方库，即使不是用ts编写的
（3）有活跃的社区，大多数的第三方库都可提供给 ts 的类型定义文件，完全支持 es6 规范
缺点：
（1）增加学习成本，需要理解接口（Interfaces）和泛型（Generics），类（class），枚举类型（Enums）
（2）短期增加开发成本，增加类型定义，但减少维护成本
（3）ts 集成到构建流程需要一定的工作量
（4）和有些库结合时不是很完美
- 十、描述引用计数的工作原理和优缺点
工作原理：每个对象增加一个引用计数器(整型)，计数器记录该对象被引用的次数，每新增一个对该对象的引用的时候计数器加 1，当引用失效时该计数器减 1，当引用为 0 则表示该对象不再被引用，会进行回收。
优点：实现简单，垃圾对象便于辨识，回收没有延迟性及时释放内存
缺点：
（1）每个字段存储计数器，增加存储空间开销；
（2）每次都需要维护引用计数器，消耗一定时间开销；
（3）循环引用无法回收，易导致内存泄漏
- 十一、标记整理算法的工作流程
第一步标记：遍历所有可达对象，将存活对象进行标记；第二步整理：移动存活对象，按照内存地址顺序排列在内存中，将内存地址末端之后的内存回收释放
- 十二、描述 V8 中新生代存储区垃圾回收的流程
采用 复制算法 + 标记整理，新生代存储区分为两个等大的 From 和 To 空间，使用空间 From ，空闲空间 To，活动对象存储在 From 空间，标记整理后将活动对象拷贝至 To，拷贝过程中可能出现晋升(晋升就是将新生代对象移动至老生代，一轮 GC 还存活的新生代需要晋升，To 空间使用率超过 25% ，也要将活动对象移动至老生代)，最后将 From 与 To 交换空间完成内存释放。
- 十三、描述增量标记算法在何时使用及工作原理
增量标记在穿插在程序运行过程中执行，在 V8 清除老生代对象时为了提高清楚效率时使用。
工作原理：在老生代中，存活对象多，导致垃圾回收时间过长，一次性标记的话停顿时间过长，为了减少停顿时间，V8 将一次停顿过程拆分为很多个小步骤和程序交替运行，最终完成清除。